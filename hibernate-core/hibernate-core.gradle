/*
 * SPDX-License-Identifier: Apache-2.0
 * Copyright Red Hat Inc. and Hibernate Authors
 */
import org.apache.tools.ant.filters.ReplaceTokens

plugins {
    id( "local.publishing-java-module" )
    id( "local.publishing-group-relocation" )

    id( "org.hibernate.orm.antlr" )
    id( "local-xjc-plugin" )
}

description = "Hibernate's core ORM functionality"

configurations {
    register( "tests" ) {
        description = "Configuration for the produced test jar"
    }
}

def coreSubprojects = [
        ":hibernate-core-api",
        ":hibernate-core-annotations",
        ":hibernate-core-bytecode",
        ":hibernate-core-internal",
        ":hibernate-core-service",
]
// Ensure subprojects are evaluated so their Java plugins and source sets are available
// this is only needed on groovy dsl
coreSubprojects.each { evaluationDependsOn(it) }

dependencies {
    api( libs.jakarta.jpa )
    api( libs.jakarta.jta )

    api( projects.hibernateCoreApi )
    api( projects.hibernateCoreAnnotations )
    api( projects.hibernateCoreBytecode )
    api( projects.hibernateCoreInternal )
    api( projects.hibernateCoreService )

    implementation( libs.hibernateModels )
    implementation( libs.classmate )
    implementation( libs.byteBuddy )

    implementation( libs.jakarta.jaxbApi )
    implementation( libs.jakarta.jaxb )
    implementation( libs.jakarta.inject )

    implementation( libs.antlrRuntime )

    compileOnly( libs.jakarta.jacc )
    compileOnly( libs.jakarta.validation )
    compileOnly( libs.jakarta.cdi )
    compileOnly( libs.jakarta.jsonbApi )
    compileOnly( libs.jackson )
    compileOnly( libs.jacksonXml )
    compileOnly( libs.jdbc.postgresql )
    compileOnly( libs.jdbc.edb )

    testImplementation( projects.hibernateTesting )
    testImplementation( projects.hibernateAnt )
    testImplementation( projects.hibernateScanJandex )

    testImplementation( libs.test.shrinkwrap )
    testImplementation( libs.test.shrinkwrapDescriptors )
    testImplementation( libs.jakarta.cdi )
    testImplementation( libs.jakarta.jacc )
    testImplementation( libs.jakarta.validation )
    testImplementation( libs.test.validator ) {
        transitive = true
    }
    testImplementation("joda-time:joda-time:2.3" )
    testImplementation( libs.jdbc.h2 )
    testImplementation( libs.hibernateModelsJandex )

    testRuntimeOnly( libs.byteBuddy )
    testRuntimeOnly( libs.test.weld )
    testRuntimeOnly( libs.test.wildFlyTxnClient )
    testImplementation( libs.jandex )
    testImplementation( libs.jakarta.jsonb )
    testImplementation( libs.jackson )
    testRuntimeOnly( libs.jacksonXml )
    testRuntimeOnly( libs.jacksonJsr310 )

    testAnnotationProcessor( projects.hibernateProcessor )

    antlr( libs.antlr )
    antlr( libs.antlrRuntime )
}

tasks.jar {
    manifest {
        attributes( "Main-Class": "org.hibernate.Version" )
    }
}

tasks.withType( JavaCompile ).configureEach {
    String pathSeparator = File.pathSeparator

    def outPath = { String prjName ->
        def prj = project(prjName)
        def ssc = prj.extensions.getByType(SourceSetContainer)
        return ssc.named("main").get().output.asPath
    }

    String patchPaths = [
            outPath(":hibernate-core-annotations"),
            outPath(":hibernate-core-api"),
            outPath(":hibernate-core-bytecode"),
            outPath(":hibernate-core-internal"),
            outPath(":hibernate-core-service"),
    ].join(pathSeparator)

    // need to patch modules of JPMS to add gradle modules (internal split) into the publishing module of hibernate-core
    // all gradle modules of hibernate core is unnamed module because JPMS prohibits split package
    options.compilerArgs.addAll(["--patch-module", "org.hibernate.orm.core=${patchPaths}"])
}

tasks.named("jar", Jar) {
    from(
        project(":hibernate-core-api").extensions.getByType(SourceSetContainer).named("main").get().output,
        project(":hibernate-core-annotations").extensions.getByType(SourceSetContainer).named("main").get().output,
        project(":hibernate-core-bytecode").extensions.getByType(SourceSetContainer).named("main").get().output,
        project(":hibernate-core-internal").extensions.getByType(SourceSetContainer).named("main").get().output,
        project(":hibernate-core-service").extensions.getByType(SourceSetContainer).named("main").get().output,
    )
}

tasks.withType( Javadoc ).configureEach {
    def submodules = coreSubprojects

    def mainSourceSet = { String prjName ->
        def prj = project(prjName)
        def ssc = prj.extensions.getByType(SourceSetContainer)
        return ssc.named("main").get()
    }

    // add submodules to source
    source submodules.collectMany { mainSourceSet(it).allJava.srcDirs }

    // add classpath of submodules
    classpath += files(submodules.collect { mainSourceSet(it).compileClasspath })
}

sourceSets {
    named( "test" ) {
        resources {
            srcDir( "src/test/resources" )
            srcDir( "src/test/bundles" )
        }
    }
}

xjc {
    outputDirectory = layout.buildDirectory.dir( "generated/sources/xjc/main" ).get().asFile

    schemas {
        cfg {
            xsdFile = file("src/main/resources/org/hibernate/xsd/cfg/legacy-configuration-4.0.xsd")
            xjcBindingFile = file("src/main/xjb/hbm-configuration-bindings.xjb")
        }
        hbm {
            xsdFile = file("src/main/resources/org/hibernate/xsd/mapping/legacy-mapping-4.0.xsd")
            xjcBindingFile = file("src/main/xjb/hbm-mapping-bindings.xjb")
            xjcExtensions("inheritance", "simplify")
        }
        configuration {
            xsdFile = file("src/main/resources/org/hibernate/xsd/cfg/configuration-3.2.0.xsd")
            xjcBindingFile = file("src/main/xjb/configuration-bindings.xjb")
            xjcExtensions("inheritance", "simplify")
        }
        mapping {
            xsdFile = file("src/main/resources/org/hibernate/xsd/mapping/mapping-7.0.xsd")
            xjcBindingFile = file("src/main/xjb/mapping-bindings.xjb")
            xjcExtensions("inheritance", "simplify")
        }
    }
}

def db = project.ext.db as String
def dbHost = project.ext.dbHost as String
def dbBundle = project.ext.dbBundle as Map<String, Map<String, String>>


def copyBundleResourcesXml = tasks.register( "copyBundleResourcesXml", Copy ) {
    inputs.property("db", db)
    inputs.property("dbHost", dbHost)

    def bundlesTargetDir = layout.buildDirectory.dir("bundles")
    def bundleTokens = dbBundle[db]?.collectEntries {key, value ->
        [(key): value.replace("&", "&amp;")]
    }
    bundleTokens["buildDirName"] = project.relativePath( layout.buildDirectory.get().asFile )

    from( "src/test/bundles/templates" ) {
        include( "**/*.xml" )
    }
    into( bundlesTargetDir )
    filter( ReplaceTokens, "tokens": bundleTokens)

    doFirst {
        bundlesTargetDir.get().asFile.mkdirs()
    }
}

def copyBundleResourcesNonXml = tasks.register( "copyBundleResourcesNonXml", Copy ) {
    inputs.property("db", db)

    def bundlesTargetDir = layout.buildDirectory.dir("bundles")
    def bundleTokens = dbBundle[db]
    bundleTokens["buildDirName"] = project.relativePath(layout.buildDirectory.get().asFile)

    from( "src/test/bundles/templates" ) {
        exclude( "**/*.xml" )
    }
    into(bundlesTargetDir)
    filter( ReplaceTokens, "tokens": bundleTokens )

    doFirst {
        bundlesTargetDir.get().asFile.mkdirs()
    }
}

def copyBundleResources = tasks.register( "copyBundleResources" ) {
    dependsOn(copyBundleResourcesXml, copyBundleResourcesNonXml)
}

tasks.named( "processTestResources", ProcessResources ) {
    dependsOn(copyBundleResources)
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
}

tasks.named( "sourcesJar", Jar ) {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    dependsOn(
            ":hibernate-core:generateGraphParser",
            ":hibernate-core:generateHqlParser",
            ":hibernate-core:generateSqlScriptParser",
            ":hibernate-core:generateOrderingParser",
    )
}

def testJar = tasks.register( "testJar", Jar ) {
    dependsOn( tasks.named( "testClasses" ) )
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    archiveClassifier.set( "test" )
    from(sourceSets.test.output)
}

artifacts.add( "tests", testJar )

tasks.register( "generateAnnotationClasses", JavaCompile ) {
    description = "Generate concrete classes for Hibernate and JPA annotations"

    source = sourceSets.main.allJava
    include( "org/hibernate/annotations/*" )
    classpath = sourceSets.main.runtimeClasspath + sourceSets.main.compileClasspath
    options.annotationProcessorPath = sourceSets.main.compileClasspath
    options.compilerArgs = [
            "-proc:only",
            "-processor",
            "org.hibernate.orm.build.annotations.ClassGeneratorProcessor"
    ]

    destinationDirectory.set( layout.buildDirectory.dir( "generated/sources/annotations/" ) )
}

tasks.register( "generateEnversStaticMetamodel", JavaCompile ) {
    source = sourceSets.main.java
    include(
            "org/hibernate/envers/DefaultRevisionEntity.java",
            "org/hibernate/envers/DefaultTrackingModifiedEntitiesRevisionEntity.java",
            "org/hibernate/envers/enhanced/SequenceIdRevisionEntity.java",
            "org/hibernate/envers/enhanced/SequenceIdTrackingModifiedEntitiesRevisionEntity.java",
    )

    classpath = sourceSets.main.runtimeClasspath + sourceSets.test.compileClasspath
    options.compilerArgs = [
            "-proc:only",
            "-processor",
            "org.hibernate.processor.HibernateProcessor"
    ]

    destinationDirectory.set( file( "${projectDir}/src/main/java" ) )
}

tasks.withType( Test ).configureEach {
    systemProperties(
            "file.encoding": "utf-8",
            "hsqldb.method_class_names": "org.hibernate.orm.test.jpa.transaction.TransactionTimeoutTest.sleep"
    )
    jvmArgs = [
            "--add-opens", "java.base/java.nio.charset=ALL-UNNAMED",
            "--add-opens", "java.base/java.security=ALL-UNNAMED",
            "--add-opens", "java.base/java.lang=ALL-UNNAMED",
            "-Dlog4j2.disableJmx=true"
    ]
    if (project.db == "h2" || project.db == "hsqldb") {
        maxParallelForks = Runtime.runtime.availableProcessors().intdiv( 2 ) ?: 1
    }
}

tasks.named( "javadoc", Javadoc ) {
    options {
        overview = rootProject.file("shared/javadoc/overview.html")
        exclude("**/internal/**", "org/hibernate/boot/jaxb/**", "org/hibernate/tuple/**")
    }
}
